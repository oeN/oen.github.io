[{"content":"During these days, I\u0026rsquo;m tidying up my homelab and found the necessity of having an internal domain to expose some apps inside my local network but not to the internet.\nFor example, I use Vault to store secrets, and I want an easy way to access the web-ui rather than using the IP address. The solution in Kubernetes is to create an Ingress; right now, I only have Ingresses with my main domain diomedet.com but if I use it will be exposed to the whole internet, and I don\u0026rsquo;t want that.\nexternal-dns is my tool of choice to handle the synchronization between my Ingresses and the DNS provider; on my local network, I use Pi-hole to filter all my DNS request and to block some of them.\nPi-hole already has a \u0026ldquo;Local DNS Records\u0026rdquo; section where you could list an arbitrary domain and point it to a specific IP inside or outside your network. So, if there is a way to make external-dns updates that list, what I\u0026rsquo;m trying to achieve would be possible with a bit of effort. Unfortunately, there is no way to update the list of local DNS records on Pi-hole programmatically at the moment of writing, so we\u0026rsquo;ve to find another way to do that.\nMessing around with the interface of Pi-hole, I\u0026rsquo;ve noticed that under \u0026ldquo;Settings -\u0026gt; DNS\u0026rdquo; you can choose which DNS server redirects all the incoming requests that the blacklist has not blocked. Besides the classic list of \u0026ldquo;Upstream DNS Servers\u0026rdquo; there is also a list of custom upstream DNS servers:\nSo, the idea is to create a custom DNS server that can be updated by external-dns and used by Pi-hole as an upstream DNS server. In this way, every Ingress with my internal domain will be resolved to the IP of my Kubernetes cluster.\nGreat, we\u0026rsquo;ve got a plan. Now it\u0026rsquo;s time to make it real!\nFirst things first, we need a DNS server Scouting between the providers supported by external-dns there a bunch of choices that can be self-hosted, something like PowerDNS or CoreDNS, at this point I was like:\n \u0026ldquo;mmh interesting, CoreDNS is the one used by Kubernetes internally must be a good choice, let\u0026rsquo;s go with it.\u0026rdquo;\n A colleague suggested using PowerDNS**, but I was already set on my path, so I stuck with **CoreDNS**.\nTo be clear, it\u0026rsquo;s not a wrong choice, but it might be a little overkill for this specific purpose but let\u0026rsquo;s see what difficulties this path reserved for us.\nIn the external-dns repo, there is a folder docs/tutorial with a markdown file for each supported provider (I think each didn\u0026rsquo;t count), we\u0026rsquo;re looking for the CoreDNS one: https://github.com/kubernetes-sigs/external-dns/blob/master/docs/tutorials/coredns.md\nIt is a tutorial for minikube, but ignoring that part, we can use it for every Kubernetes cluster and bonus point, show us even how to install CoreDNS, great two birds with one stone.\nIf you\u0026rsquo;ve opened the file, you can see from the very beginning that the birds are not two anymore but three. The more, the merrier, right, right?!\nIf you haven\u0026rsquo;t opened the link, let me recap that for you what we need to install:\n CoreDNS (obviously) etcd another instance of external-dns (you need an instance of external-dns for each dns provider you\u0026rsquo;re going to support)  Wait, why we need etcd? We need etcd because this is the way how external-dns talks to CoreDNS, we have to create a section in the configuration of CoreDNS that tells him to read the value from a specific path on the etcd instance we\u0026rsquo;re going to configure and external-dns will update the same path with the information about the Ingresses we\u0026rsquo;re going to create with our internal domain.\nNote: Before switching to etcd directly, CoreDNS was using SkyDNS (a service built on top of etcd) to serve these kinds of request, so, in the manifest files, we\u0026rsquo;re going to see you\u0026rsquo;ll find some refuse of that implementation.\nInstall etcd Let\u0026rsquo;s get down to business and install etcd. In the end, it is a core component of Kubernetes; there nothing wrong with learning more about it. Just to let you know, don\u0026rsquo;t use the internal etcd for a user application (like the one we want to install here); it is not meant for that.\nThe tutorial linked above suggests we use the etcd-operator and use https://raw.githubusercontent.com/coreos/etcd-operator/HEAD/example/example-etcd-cluster.yaml to create our etcd cluster.\n Great, an operator nothing more simple than that\u0026hellip;\n Slow down; the etcd-operator repo was archived more than a year ago; even if it could work for a case like this, we don\u0026rsquo;t want to install an operator that is not maintained anymore, so let\u0026rsquo;s see how to deploy it manually.\nAfter searching around, I ended up on this documentation page https://etcd.io/docs/v3.4/op-guide/container/#docker that shows how to deploy, etcd with a single node configuration; prefect is what we need here.\nBasically we need to port the command showed in the link in a manifest for kubernetes:\ndocker run from etcd documentation\ndocker run \\  -p 2379:2379 \\  -p 2380:2380 \\  --volume=${DATA_DIR}:/etcd-data \\  --name etcd ${REGISTRY}:latest \\  /usr/local/bin/etcd \\  --data-dir=/etcd-data --name node1 \\  --initial-advertise-peer-urls http://${NODE1}:2380 --listen-peer-urls http://0.0.0.0:2380 \\  --advertise-client-urls http://${NODE1}:2379 --listen-client-urls http://0.0.0.0:2379 \\  --initial-cluster node1=http://${NODE1}:2380 Manifest file etc-sts.yml\napiVersion: apps/v1 kind: StatefulSet metadata: name: etcd labels: app.kubernetes.io/name: etcd spec: serviceName: etcd replicas: 1 updateStrategy: type: OnDelete selector: matchLabels: app.kubernetes.io/name: etcd template: metadata: labels: app.kubernetes.io/name: etcd spec: containers: - name: etcd image: gcr.io/etcd-development/etcd:latest imagePullPolicy: IfNotPresent command: - /usr/local/bin/etcd env: - name: ETCD_NAME value: node1 - name: ETCD_DATA_DIR value: /etcd-data - name: ETCD_LISTEN_PEER_URLS value: http://0.0.0.0:2380 - name: ETCD_LISTEN_CLIENT_URLS value: http://0.0.0.0:2379 - name: ETCD_INITIAL_ADVERTISE_PEER_URLS value: http://0.0.0.0:2380 - name: ETCD_ADVERTISE_CLIENT_URLS value: http://0.0.0.0:2379 - name: ETCD_INITIAL_CLUSTER value: \u0026#34;node1=http://0.0.0.0:2380\u0026#34; volumeMounts: - name: data mountPath: /etcd-data ports: - containerPort: 2379 name: client - containerPort: 2380 name: peer volumeClaimTemplates: - metadata: name: data spec: accessModes: - ReadWriteOnce resources: requests: storage: 1Gi # we don\u0026#39;t need much space to store DNS information We\u0026rsquo;re going to use a StatefulSet because etcd is a stateful app and needs a volume to persist its data. Rather than the classic Deploy with a StatefulSet we\u0026rsquo;re certain that the generated pod will always receive the same name, and the volume attached to it will always be the same. More on the StatefulSet\nThe only noticeable difference between the docker run ... command and this manifest file is that we\u0026rsquo;re using environment variables instead of configuration flags. I had some trouble getting the flags working, and I like more the environment variables, anyway; here a list of etcd configuration flags with the matching variable.\nNow, in order to expose etcd to the other applications in the cluster we need to create a Service too:\netc-service.yml\napiVersion: v1 kind: Service metadata: name: etcd labels: app.kubernetes.io/name: etcd spec: ports: - port: 2379 targetPort: 2379 name: client - port: 2380 targetPort: 2380 name: peer selector: app.kubernetes.io/name: etcd Nothing special here, but this completes the manifest needed for our etcd instance.\nInstall CoreDNS Now that we have our etcd, we can continue with the tutorial and install our custom version of CoreDSN. You can use helm to install it, or if you want a more instructive approach, you can use helm template to render the file and applying them manually or with kustomize. In this way, you can check them individually to see what the chart will create in your cluster.\nSince my homelab is a way to learn more about Kubernetes, I choose to render the file with helm template and use kustomize to apply them later.\nWhichever way you choose, the important part is to set a couple of options inside the values.yml file correctly.\n# if you don\u0026#39;t have RBAC enabled on your cluster, I think you can set this to false rbac: create: true # isClusterService specifies whether the chart should be deployed as cluster-service or regular k8s app. isClusterService: true servers: - zones: - zone: . port: 53 plugins: ... # all other plugins - name: forward parameters: . 8.8.8.8:53 # tells where to forward all the DNS requests that CoreDNS can\u0026#39;t solve - name: etcd parameters: diomedet.internal # insert your domain here configBlock: |-stubzones path /skydns endpoint http://etcd:2379 The most important part is the last one, we\u0026rsquo;re going to configure the etcd plugin and tell CoreDNS to look inside the http://etcd:2379 to find the information about the domain diomedet.internal (this is my internal domain)\nAlso, the forward part is important; it tells CoreDNS where to redirect all the DNS that it can\u0026rsquo;t solve. Later on, I\u0026rsquo;ll explain why it is crucial.\nWith these values, we can run the command.\nhelm template custom coredns/coredns --output-dir . --values values.yaml\n(custom is the name of my release, then it\u0026rsquo;ll turn out in custom-coredns)\nHelm will create a folder coredns/template with five files in it:\ncoredns/templates ├── clusterrole.yaml ├── clusterrolebinding.yaml ├── configmap.yaml ├── deployment.yaml └── service.yaml Now the only thing we\u0026rsquo;ve to do is to kubectl apply these files, and we\u0026rsquo;ll end up with a working CoreDNS instance. Working but still not reachable outside the cluster, if you have MetalLB configured, you can change the ServiceType from ClusterIP to LoadBalancer to get an IP. I haven\u0026rsquo;t this feature in my cluster yet, so for now, I\u0026rsquo;m going to use the NodePort type; this allows me to use a port of my node and point it to the service.\nWith kustomize, there is the concept of patches, so I can create a patch that will modify the service.yaml file without directly touching it. I prefer this way, so if I have to re-run helm template ... I don\u0026rsquo;t have to mind any modification I could have made because kustomize will patch everything.\npatches/service.yaml\napiVersion: v1 kind: Service metadata: name: custom-coredns spec: type: NodePort ports: - {port: 53, protocol: UDP, name: udp-53, nodePort: 30053} - {port: 53, protocol: TCP, name: tcp-53, nodePort: 30053} Here I tell Kubernetes to use the port 30053 for both UDP and TCP. With the NodePort, you can use ports from 30000 to 32767 if you do not modify it.\nTo wrap it up, here my kustomization.yml file:\nkind: Kustomization apiVersion: kustomize.config.k8s.io/v1beta1 namespace: custom-coredns resources: - templates/clusterrole.yaml - templates/clusterrolebinding.yaml - templates/configmap.yaml - templates/deployment.yaml - templates/service.yaml - etcd-sts.yml - etcd-service.yml patchesStrategicMerge: - patches/service.yaml If you followed my path, you should have all the files to make it work, anyway. If you\u0026rsquo;ve installed the helm chart directly, you can always change the service manifest directly on Kubernetes. You can even set the serviceType in the values.yaml file, but I didn\u0026rsquo;t find a way to specify the nodePort to use, so I decided to go with the patch.\nFinally, install external-dns Now we can finally install the instance of external-dns that will monitor the Ingress created with our internal domain.\nI have RBAC enabled on my cluster, so my manifest look like this:\nexternal-dns.yml\n--- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRole metadata: name: external-dns rules: - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;services\u0026#34;,\u0026#34;endpoints\u0026#34;,\u0026#34;pods\u0026#34;] verbs: [\u0026#34;get\u0026#34;,\u0026#34;watch\u0026#34;,\u0026#34;list\u0026#34;] - apiGroups: [\u0026#34;extensions\u0026#34;,\u0026#34;networking.k8s.io\u0026#34;] resources: [\u0026#34;ingresses\u0026#34;] verbs: [\u0026#34;get\u0026#34;,\u0026#34;watch\u0026#34;,\u0026#34;list\u0026#34;] - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;nodes\u0026#34;] verbs: [\u0026#34;list\u0026#34;] --- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRoleBinding metadata: name: external-dns-viewer roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: external-dns subjects: - kind: ServiceAccount name: external-dns namespace: external-dns --- apiVersion: v1 kind: ServiceAccount metadata: name: external-dns namespace: external-dns --- apiVersion: apps/v1 kind: Deployment metadata: name: external-dns spec: strategy: type: Recreate selector: matchLabels: app: external-dns template: metadata: labels: app: external-dns spec: serviceAccountName: external-dns containers: - name: external-dns image: k8s.gcr.io/external-dns/external-dns:v0.7.6 args: - --source=ingress - --provider=coredns - --log-level=debug # debug only - --domain-filter=diomedet.internal env: - name: ETCD_URLS value: http://etcd.custom-coredns:2379 If you don\u0026rsquo;t have RBAC enable, you can use only the Deployment manifest.\nThis is the most straightforward part, just set the correct ETCD_URLS with the correct value, and you\u0026rsquo;re good to go. I have deployed my external-dns in a namespace different than the etcd one, so in the ETCD_URLS variable, I have to specify the service with the namespace too http://etcd.custom-coredns:2379\nOnce you applied your manifest you can create an ingress with the internal domain you chose, in my case is something like:\nvault/ingress.yml\napiVersion: networking.k8s.io/v1beta1 kind: Ingress metadata: annotations: kubernetes.io/ingress.class: nginx name: vault-ui-internal namespace: vault spec: rules: - host: vault.diomedet.internal http: paths: - backend: serviceName: vault servicePort: http path: / After you create an Ingress with your internal domain on the external-dns pod, you should see a log like the following one:\nlevel=debug msg=\u0026quot;Endpoints generated from ingress: vault/vault-ui-internal: [vault.diomedet.internal 0 IN A 10.10.5.123 []]\u0026quot;\n10.10.5.123 is the IP address of my Kubernetes cluster, it\u0026rsquo;s called \u0026ldquo;Scyther\u0026rdquo;, the Pokédex number of Scyther is #123, so here explained my IP, not that you asked, but here it is anyway :P\nNow, if I use dig to check the name resolution, it should work correctly:\n❯ dig @10.10.5.123 -p 30053 vault.diomedet.internal ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.11.3-1ubuntu1.13-Ubuntu \u0026lt;\u0026lt;\u0026gt;\u0026gt; @10.10.5.123 -p 30053 vault.diomedet.internal ; (1 server found) ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 5546 ;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; WARNING: recursion requested but not available ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 4096 ; COOKIE: bc40278d825e2b16 (echoed) ;; QUESTION SECTION: ;vault.diomedet.internal. IN A ;; ANSWER SECTION: vault.diomedet.internal. 30 IN A 10.10.5.123 ;; Query time: 3 msec ;; SERVER: 10.10.5.123#30053(10.10.5.123) ;; WHEN: Sat May 08 16:11:48 CEST 2021 ;; MSG SIZE rcvd: 103 But if I run the nslookup command, I still get an error:\n❯ nslookup vault.diomedet.internal Server: 172.29.96.1 Address: 172.29.96.1#53 ** server can\u0026#39;t find vault.diomedet.internal: NXDOMAIN This error appears because we still have to change the Pi-hole configurations.\nConfigure Pi-hole to use our new DNS Server To configure Pi-hole, you need to return to DNS Setting tab http://pihole.local/admin/settings.php?tab=dns, uncheck all the \u0026ldquo;Upstream DNS Servers\u0026rdquo; and insert your custom one, in my case 10.10.5.123#300123 (the # is used to specify the port).\nNow, if you run the nslookup command again, you should end with the correct result:\n❯ nslookup vault.diomedet.internal Server: 172.29.96.1 Address: 172.29.96.1#53 Non-authoritative answer: Name: vault.diomedet.internal Address: 10.10.5.123 Great! We can create as many Ingress with our internal domain as we want, and they will always be resolved to our cluster IP.\nConclusion Unfortunately, our instance of CoreDNS will become a central point for our network in this scenario. If something happens to our cluster or the CoreDNS pod stops, we\u0026rsquo;ll lose the ability to resolve domain names. I\u0026rsquo;m still searching for a way to solve this problem and have a more reliable solution, but for now, I have to stick with this downside.\nDo you remember the forward value that we set on the values.yaml for CoreDNS?\nThat option has become the only way to choose which DNS server we want to use to solve all the DNS requests that can\u0026rsquo;t be solved internally and aren\u0026rsquo;t blocked by Pi-hole. This is because if we check some of the \u0026ldquo;Upstream DNS Server\u0026rdquo;, we\u0026rsquo;ll lose the ability to resolve our internal domain.\nI have some ideas on how to do that:\n A second Pi-hole that is going to be my \u0026ldquo;Custom 2\u0026rdquo; upstream DNS Server An ingress that mask the IP of the DNS server I want to use, something like I\u0026rsquo;ve done in a previous post Expose an external resource with a Kubernetes Ingress  But I haven\u0026rsquo;t tested any of that, so, for today, this is it.\nI\u0026rsquo;m also looking for a way to have a certificate on my internal domain, so I don\u0026rsquo;t get those annoying alerts when I\u0026rsquo;m trying to access my apps via HTTPS.\nI hope you\u0026rsquo;ve found this article helpful. Stay tuned for future updates!\n","permalink":"https://diomedet.com/posts/kubernetes-external-dns-pihole-and-a-custom-domain/","summary":"During these days, I\u0026rsquo;m tidying up my homelab and found the necessity of having an internal domain to expose some apps inside my local network but not to the internet.\nFor example, I use Vault to store secrets, and I want an easy way to access the web-ui rather than using the IP address. The solution in Kubernetes is to create an Ingress; right now, I only have Ingresses with my main domain diomedet.","title":"Kubernetes, external-dns, Pi-hole and a custom domain"},{"content":"The other night I was wandering around my homelab and noticed that I didn\u0026rsquo;t correctly expose my new home assistant instance to the internet. Some months ago, home assistant (from now on HA) found its new permanent home, a Rasperry PI 4 4GB; since we\u0026rsquo;re in lockdown, I didn\u0026rsquo;t need to reach HA outside my local network.\nI\u0026rsquo;m still working from home (and love it), but it\u0026rsquo;s time to fix this now. While choosing which method was the best to expose it, I had an idea, why not use an Ingress in my Kubernetes cluster?\nIt could seem a little odd, but hear me out:\n I already have a Kubernetes cluster, with cert-manager configured and working I\u0026rsquo;m planning to move some service into the cluster, and they\u0026rsquo;ll need to reach HA anyway I want to learn as much as I can about Kubernetes, and this seemed a good chance  So, to achieve my goal, I need one thing: how can I point a Kubernetes Service to an external resource?\nWait, why a Service? Didn\u0026rsquo;t you mention an Ingress before? Yes, you\u0026rsquo;re right but bear with me.\nIn Kubernetes, an Ingress needs a Service to redirect all the requests it receives, so to properly expose HA with an Ingress, we need to create a Service that can point to it.\nUsually, a Service is used to expose a set of Pods; in this way, if different applications need to talk to each other, they don\u0026rsquo;t need to use their pod names (that could change variously), but they can use the Service name.\nWhen we create a Service, another resource is automatically created, an Endpoint. This Endpoint includes the references (all the IP addresses) of the Pods that match the selector we\u0026rsquo;ve specified in the Service selector spec.\nThe Endpoint created in this way will have the same name as the Service we\u0026rsquo;ve created.\nBut here\u0026rsquo;s the thing, we can create a Service without a selector, and if we do that, we also need to create an Endpoint ourselves, and this Endpoint could point to an IP outside the Kubernetes cluster.\nSo let\u0026rsquo;s see the YAML we need to create to expose HA using a Kubernetes Ingress.\nendpoint.yml\napiVersion: v1 kind: Endpoints metadata: name: home-assistant subsets: - addresses: - ip: 1.1.1.1 # Insert your home-assistant IP here ports: - name: ha port: 8123 protocol: TCP service.yml\napiVersion: v1 kind: Service metadata: name: home-assistant spec: ports: - name: ha port: 80 protocol: TCP targetPort: 8123 type: ClusterIP clusterIP: None Note: we set the clusterIP property to None on purpose; this tells Kubernetes not to provide an IP to this Service; we don\u0026rsquo;t need it. A Service like this is also known as headless Service.\ningress.yml\napiVersion: networking.k8s.io/v1beta1 kind: Ingress metadata: annotations: kubernetes.io/ingress.class: nginx cert-manager.io/cluster-issuer: \u0026#34;letsencrypt-prod\u0026#34; name: home-assistant spec: rules: - host: ha.awesome-domain.com # insert your domain here http: paths: - backend: serviceName: home-assistant servicePort: ha path: / tls: - hosts: - ha.awesome-domain.com # insert your domain here secretName: home-assistant-tls Now, if we run kubectl apply -f ... for all these three files after cert-manager has finished its work, we\u0026rsquo;ll end with a domain with a valid certificate that points to our Home Assistant instance outside of Kubernetes.\nAnd remember that I told you that I want to move some service that uses HA inside my k8s cluster? Now, all I have to do is deploy them and use `home-assistant as the URL for HA instead of using the IP address.\nFor the sake of completion, if you already have a local domain for your HA instance, you can skip the creation of the Endpoint and use the Service\u0026rsquo;s externalName property directly.\n","permalink":"https://diomedet.com/posts/expose-an-external-resource-with-a-kubernetes-ingress/","summary":"The other night I was wandering around my homelab and noticed that I didn\u0026rsquo;t correctly expose my new home assistant instance to the internet. Some months ago, home assistant (from now on HA) found its new permanent home, a Rasperry PI 4 4GB; since we\u0026rsquo;re in lockdown, I didn\u0026rsquo;t need to reach HA outside my local network.\nI\u0026rsquo;m still working from home (and love it), but it\u0026rsquo;s time to fix this now.","title":"Expose an external resource with a Kubernetes Ingress"},{"content":"I\u0026rsquo;m not that good at talking about myself, but I\u0026rsquo;ll try it anyway.\nI\u0026rsquo;ve moved across several programming languages during the years, reaching the point where the language itself is not that important anymore. What\u0026rsquo;s matters are just the thoughts behind it.\nIn recent times I discover that I like more setting up the infrastructure where the code runs rather than writing the code myself; it feels like I can be helpful for more people. Any project needs good infrastructure to properly works.\nI\u0026rsquo;ve also started an homelab (once ready, I\u0026rsquo;ll link the page of my actual homelab). Right now is a little messy but is constantly improving; we can continuously improve in some way.\nThere are a lot of other things that I could say, but for this page, I\u0026rsquo;ll stop here, I have a complicated relationship with social networks, so probably you can\u0026rsquo;t find me there; I\u0026rsquo;m trying to revive my Twitter account, but no promise :P Anyway, if you\u0026rsquo;re reading this page, it means that my site is up and running, and I should work on my blog, so look at it and see if you find something interesting!\n","permalink":"https://diomedet.com/about/","summary":"about","title":"About Me"}]